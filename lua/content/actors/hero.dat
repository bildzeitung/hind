{
	_baseTable = 'content/actors/male_human.dat',	
	dead = false,
	HERO = true,
	_maxInventoryCount = 72,
	_attributes = 
	{
		experience = 0, gold = 0, greed = 0,
		likeable = 0, luck = 0, alignment = 0,
		mana = 200, manaRegen = 100, currentSpell = 1
	},
	_spells = 
	{
		{ 'firelion', 'Fire Lion', 50 },
		{ 'iceshield', 'Ice Shield', 50 }
	},
	update = function(self,dt)
		objects.Actor.update(self,dt)
		
		self._manaRegen = self._manaRegen + dt
		if self._manaRegen > 1 then
			self._mana = self._mana + 1
			self._manaRegen = self._manaRegen - 1
			if self._mana > 200 then
				self._mana = 200
			end			
		end
	end,
	on_begin_spellcast = function(self)
		local spell = self._spells[self._currentSpell]
		if spell[3] > self._mana then return false end
		self._mana = self._mana - spell[3]		
		self:velocity(0,0)
	end,
	on_end_spellcast = function(self)
		local spell = self._spells[self._currentSpell]
		local magic = 
			factories.createActor('content/actors/magic_'..
			spell[1] .. '.dat')			
		magic._actor = self
		self:ignoreCollision(magic)
		magic:ignoreCollision(self)				
		magic:map(daMap)	
		magic:animation('attack'..self:direction())				
		magic:position(self._position[1], self._position[2])
		magic:update(0)
		magic:registerBuckets(buckets)				
		magic:action('attack')
	end,
	on_begin_attack = function(self)
		self:velocity(0,0)
		
		local sound = 'human_attack_' .. math.floor(math.random() * 4) + 1
		soundEffects[sound]:rewind()
		love.audio.play(soundEffects[sound])
		
		local weapon = self._equipped['weapon']	
		if weapon then
			weapon:on_begin_attack()
		end
	end,
	on_end_attack = function(self)
		local weapon = self._equipped['weapon']	
		if weapon then
			weapon:on_end_attack()
		end
	end,
	on_take_damage = function(self, damage)
		createFloatingText({255,0,0,255},self, damage)
		soundEffects['human_hurt_1']:rewind()
		love.audio.play(soundEffects['human_hurt_1'])		
	end,
	on_begin_die = function(self, other)		
		self:velocity(0,0)
	end,	
	on_end_die = function(self, other)			
		self.dead = true
	end,
	inventoryContains = function(self, item)
		for k, v in ipairs(self._inventory) do			
			if type(item) == 'string' then
				if v:name() == item then return true end
			end
		end
		return false
	end,
	itemFits = function(self, item)
		if #self._inventory < self._maxInventoryCount then
			return true
		end
		
		if item:stackable() then
			for k, v in ipairs(self._inventory) do
				if v:name() == item:name() and 
					v:count() < v:maxCount() then
						return true
				end
			end			
		end
		
		return false
	end,
	discardItem = function(self, item)
		for k, v in ipairs(self._inventory) do
			if type(item) == 'string' then
				if v:name() == item then 
					table.remove(self._inventory, k)
				end
			end
		end
	end,
	addItem = function(self, item)
		if not self:itemFits(item) then			
			if self.on_add_item_fail then			
				self:on_add_item_fail(item)
			end
			return nil
		end
		
		local added = false

		if item:stackable() then
			for k, v in ipairs(self._inventory) do
				if v:name() == item:name() and 
					v:count() < v:maxCount() then
						v:count(1)
						added = true
						break				
				end
			end			
		end

		if not added then
			table.insert(self._inventory, item)
			item:count(1, true)
		end
		
		return true
	end
}